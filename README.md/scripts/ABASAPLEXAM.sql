-- 01_PHASE_TABLES.sql
-- Phase I: Table creation (use XEPDB1 container if needed)

SET SERVEROUTPUT ON


-- Create tables
CREATE TABLE mine_site (
    site_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    site_name   VARCHAR2(100) NOT NULL,
    location    VARCHAR2(200),
    region      VARCHAR2(50),
    manager_name VARCHAR2(100),
    created_on  DATE DEFAULT SYSDATE
);

CREATE TABLE mineral (
    mineral_id   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    mineral_name VARCHAR2(100) NOT NULL UNIQUE,
    market_price NUMBER(14,2) DEFAULT 0,
    unit         VARCHAR2(20) DEFAULT 'ton'
);

CREATE TABLE worker (
    worker_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name          VARCHAR2(100) NOT NULL,
    role          VARCHAR2(50),
    assigned_site NUMBER,
    hire_date     DATE,
    safety_status VARCHAR2(20) DEFAULT 'CLEARED',
    contact       VARCHAR2(50),
    CONSTRAINT fk_worker_site FOREIGN KEY (assigned_site) REFERENCES mine_site(site_id)
);

CREATE TABLE machinery (
    machine_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    machine_name    VARCHAR2(100),
    site_id         NUMBER,
    last_maintenance DATE,
    next_maintenance DATE,
    status          VARCHAR2(20),
    hours_run       NUMBER DEFAULT 0,
    CONSTRAINT fk_machinery_site FOREIGN KEY (site_id) REFERENCES mine_site(site_id)
);

CREATE TABLE extraction (
    extraction_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    site_id            NUMBER NOT NULL,
    mineral_id         NUMBER NOT NULL,
    date_extracted     DATE NOT NULL,
    quantity_tons      NUMBER(12,3) DEFAULT 0,
    shift              VARCHAR2(10),
    operator_id        NUMBER,
    revenue_calculated NUMBER(20,2),
    CONSTRAINT fk_ex_site    FOREIGN KEY (site_id)    REFERENCES mine_site(site_id),
    CONSTRAINT fk_ex_mineral FOREIGN KEY (mineral_id) REFERENCES mineral(mineral_id),
    CONSTRAINT fk_ex_worker  FOREIGN KEY (operator_id) REFERENCES worker(worker_id)
);

CREATE TABLE safety_report (
    report_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    site_id        NUMBER,
    worker_id      NUMBER,
    incident_type  VARCHAR2(100),
    date_reported  DATE DEFAULT SYSDATE,
    severity_level NUMBER(1),
    description    VARCHAR2(2000),
    action_taken   VARCHAR2(500),
    CONSTRAINT fk_safety_site   FOREIGN KEY (site_id)   REFERENCES mine_site(site_id),
    CONSTRAINT fk_safety_worker FOREIGN KEY (worker_id) REFERENCES worker(worker_id)
);

CREATE TABLE environment_conservation (
    conservation_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    site_id         NUMBER,
    activity_type   VARCHAR2(100),
    date_recorded   DATE DEFAULT SYSDATE,
    impact_level    NUMBER(1),
    notes           VARCHAR2(2000),
    CONSTRAINT fk_cons_site FOREIGN KEY (site_id) REFERENCES mine_site(site_id)
);

CREATE TABLE audit_log (
    audit_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username     VARCHAR2(100),
    action       VARCHAR2(100),
    object_type  VARCHAR2(50),
    object_id    VARCHAR2(100),
    attempted_on DATE DEFAULT SYSDATE,
    success_flag VARCHAR2(10),
    message      VARCHAR2(2000)
);

CREATE TABLE holiday (
    holiday_date DATE PRIMARY KEY,
    description  VARCHAR2(200)
);

CREATE TABLE dummy_extractions_table (
    extraction_id NUMBER PRIMARY KEY,
    site_id       NUMBER,
    mineral_type  VARCHAR2(50),
    quantity      NUMBER,
    extraction_date DATE
);

COMMIT;


-- 02_PHASE_SEQUENCES.sql
-- Sequences (Phase II). Uses EXECUTE IMMEDIATE to avoid ORA-00955 on reruns.

BEGIN
    EXECUTE IMMEDIATE 'CREATE SEQUENCE extraction_seq START WITH 1 INCREMENT BY 1 NOCACHE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -955 THEN RAISE; END IF;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'CREATE SEQUENCE worker_seq START WITH 1 INCREMENT BY 1 NOCACHE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -955 THEN RAISE; END IF;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'CREATE SEQUENCE machine_seq START WITH 1 INCREMENT BY 1 NOCACHE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -955 THEN RAISE; END IF;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'CREATE SEQUENCE site_seq START WITH 1 INCREMENT BY 1 NOCACHE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -955 THEN RAISE; END IF;
END;
/
COMMIT;



-- 03_PHASE_CONSTRAINTS.sql
-- Additional indexes/constraints if needed (Phase III)

-- Example: Add index for extraction date for analytics performance
CREATE INDEX idx_extraction_date ON extraction(date_extracted);

-- Example: Ensure worker contact unique (optional - comment if duplicates exist)
-- CREATE UNIQUE INDEX ux_worker_contact ON worker(contact);

COMMIT;


-- 04_PHASE_TABLESPACE.sql
-- Tablespace creation (run in XEPDB1 as SYSDBA if you have file path)
-- Adjust DATAFILE path to your environment before running.


ALTER PLUGGABLE DATABASE TUESDAY_27625_BOSCO_SMARTMINING OPEN;

CREATE TABLESPACE SMART_TBS
DATAFILE 'C:\app\jeanb\product\21c\oradata\XE\XEPDB1\smart_tbs01.dbf'
SIZE 200M
AUTOEXTEND ON NEXT 50M MAXSIZE UNLIMITED;
-- Optionally create user and grant (comment / adjust as needed)
-- CREATE USER MINING1 IDENTIFIED BY Smart2026 DEFAULT TABLESPACE SMART_TBS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON SMART_TBS;
-- GRANT CONNECT, RESOURCE, CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE PROCEDURE TO MINING1;
COMMIT;


-- 05_PHASE_SAMPLE_DATA.sql
-- Sample data (Phase V). Uses your provided data plus generators.

SET SERVEROUTPUT ON;

-- Insert initial mine sites (your data)
BEGIN
    FOR i IN 1..10 LOOP
        INSERT INTO mine_site(site_name, location, region, manager_name)
        VALUES('Site ' || i, 'Location ' || i, CASE WHEN MOD(i,2)=0 THEN 'North' ELSE 'South' END, 'Manager ' || i);
    END LOOP;
    COMMIT;
END;
/

INSERT INTO mineral(mineral_name, market_price, unit) VALUES('Gold',   65000, 'kg');
INSERT INTO mineral(mineral_name, market_price, unit) VALUES('Copper', 6000,  'ton');
INSERT INTO mineral(mineral_name, market_price, unit) VALUES('Iron',   100,   'ton');
INSERT INTO mineral(mineral_name, market_price,unit) values('Silver',  2000, 'kg');
INSERT INTO mineral(mineral_name, market_price, unit) values('Nyiramujyejyeri', 3000, 'kg');
INSERT INTO mineral(mineral_name, market_price, unit) VALUES('Sand', 1000, 'ton');
COMMIT;

INSERT INTO mine_site (site_name, location, region, manager_name)
VALUES ('Gicumbi Gold Site', 'Gicumbi ? Northern Province', 'North', 'Gervais');

INSERT INTO mine_site (site_name, location, region, manager_name)
VALUES ('Kayonza Copper Mine', 'Kayonza - Eastern Province', 'East', 'Calvin');

INSERT INTO mine_site (site_name, location, region, manager_name)
VALUES ('Musanze Mixed Minerals', 'Musanze - Northern Province', 'North', 'Kelly');

INSERT INTO mine_site (site_name, location, region, manager_name)
VALUES ('Kigali Central Processing', 'Gasabo - Kigali City', 'Kigali', 'Mugwa');

INSERT INTO mine_site (site_name, location, region, manager_name)
VALUES ('Huye Mixed Mineral', 'Huye - Southern Province', 'South', 'Louange');
COMMIT;

-- initial workers (few examples)
INSERT INTO worker (name, role, assigned_site, hire_date, contact)
VALUES ('John Nshokeyehe', 'Operator', 1, DATE '2020-04-11', '0791906031');
INSERT INTO worker (name, role, assigned_site, hire_date, contact)
VALUES ('Niyonizeye Melise', 'Technician', 2, DATE '2016-06-28', '0787833662');
INSERT INTO worker (name, role, assigned_site, hire_date, contact)
VALUES ('Ange Munyaneza', 'Operator', 3, DATE '2000-10-06', '0783674635');
INSERT INTO worker (name, role, assigned_site, hire_date, contact)
VALUES ('Bizimana Ange', 'Safety Officer', 4, DATE '1999-01-07', '0780739125');
INSERT INTO worker (name, role, assigned_site, hire_date, contact)
VALUES ('Nyirimpeta Yabesi', 'Technician', 5, DATE '2018-02-12', '0789104309');
COMMIT;

-- initial machinery
INSERT INTO machinery(machine_name, site_id, last_maintenance, next_maintenance, status, hours_run)
VALUES ('Excavator A1', 1, DATE '2024-11-10', DATE '2025-04-10', 'Active', 1200);
INSERT INTO machinery(machine_name, site_id, last_maintenance, next_maintenance, status, hours_run)
VALUES ('Drill Machine B7', 2, DATE '2012-03-03', DATE '2013-01-02', 'Active', 980);
INSERT INTO machinery(machine_name, site_id, last_maintenance, next_maintenance, status, hours_run)
VALUES ('Loader C3', 3, DATE '2017-12-20', DATE '2020-02-25', 'Active', 1500);
INSERT INTO machinery(machine_name, site_id, last_maintenance, next_maintenance, status, hours_run)
VALUES ('Crusher D4', 4, DATE '2024-12-20', DATE '2025-02-28', 'Active', 800);
COMMIT;

-- initial extraction examples
INSERT INTO extraction (site_id, mineral_id, date_extracted, quantity_tons, shift, operator_id)
VALUES (1, 1, DATE '2025-02-11', 1.000, 'Day', 1);
INSERT INTO extraction (site_id, mineral_id, date_extracted, quantity_tons, shift, operator_id)
VALUES (1, 2, DATE '2025-06-02', 0.800, 'Night', 2);
INSERT INTO extraction (site_id, mineral_id, date_extracted, quantity_tons, shift, operator_id)
VALUES (3, 3, DATE '2022-09-02', 34.000, 'Day', 3);
INSERT INTO extraction (site_id, mineral_id, date_extracted, quantity_tons, shift, operator_id)
VALUES (4, 1, DATE '2025-01-21', 120.000, 'Day', 4);
INSERT INTO extraction (site_id, mineral_id, date_extracted, quantity_tons, shift, operator_id)
VALUES (4, 1, DATE '2025-08-19', 0.900, 'Day', NULL);
COMMIT;

-- initial safety reports
INSERT INTO safety_report (site_id, worker_id, incident_type, severity_level, description, action_taken)
VALUES (1, 1, 'Minor slip', 1, 'Worker slipped near wet area', 'Area cleaned and worker cleared');
INSERT INTO safety_report (site_id, worker_id, incident_type, severity_level, description, action_taken)
VALUES (3, 4, 'Machine malfunction', 3, 'Drill machine overheated', 'Machine shut down and repaired');
INSERT INTO safety_report (site_id, worker_id, incident_type, severity_level, description, action_taken)
VALUES (2, 3, 'Dust exposure', 2, 'Worker inhaled dust during drilling', 'Protective gear provided');
COMMIT;

-- initial environment conservation rows
INSERT INTO environment_conservation (site_id, activity_type, impact_level, notes)
VALUES (1, 'Tree planting', 1, 'Planted 50 trees around the mining zone');
INSERT INTO environment_conservation (site_id, activity_type, impact_level, notes)
VALUES (2, 'Water treatment', 2, 'Filtered waste water before release');
INSERT INTO environment_conservation (site_id, activity_type, impact_level, notes)
VALUES (3, 'Land restoration', 3, 'Soil backfilling after extraction');
COMMIT;

-- initial holidays
INSERT INTO holiday (holiday_date, description) VALUES (DATE '2025-12-25', 'Christmas');
INSERT INTO holiday (holiday_date, description) VALUES (DATE '2026-01-01', 'New Year Day');
INSERT INTO holiday (holiday_date, description) VALUES (DATE '2025-12-26', 'Boxing Day');
COMMIT;

-- Bulk generators you can run when ready (generates ~250 workers and ~80 machinery)
-- Worker generator
BEGIN
    FOR i IN 1..250 LOOP
        INSERT INTO worker (name, role, assigned_site, hire_date, contact)
        VALUES (
            'Worker ' || i,
            CASE WHEN MOD(i,3)=0 THEN 'Technician'
                 WHEN MOD(i,3)=1 THEN 'Operator'
                 ELSE 'Supervisor' END,
            MOD(i,10)+1,
            ADD_MONTHS(TRUNC(SYSDATE), -MOD(i,200)),
            '078000' || TO_CHAR(i)
        );
    END LOOP;
    COMMIT;
END;
/

-- Machinery generator
BEGIN
    FOR i IN 1..80 LOOP
        INSERT INTO machinery (machine_name, site_id, last_maintenance, next_maintenance, status, hours_run)
        VALUES (
            'Machine-' || i,
            MOD(i,10)+1,
            TRUNC(SYSDATE) - MOD(i,400),
            TRUNC(SYSDATE) + MOD(i,120),
            'Active',
            ROUND(DBMS_RANDOM.VALUE(100,5000))
        );
    END LOOP;
    COMMIT;
END;
/



-- 06_PHASE_PL_SQL.sql
-- PL/SQL: packages, procedures, functions, bulk load, exceptions, IN/OUT examples (Phase VI and additions)

SET SERVEROUTPUT ON;

-- Centralized audit package
CREATE OR REPLACE PACKAGE audit_pkg AS
    PROCEDURE log_action(
        p_username    IN VARCHAR2,
        p_action      IN VARCHAR2,
        p_object_type IN VARCHAR2,
        p_object_id   IN VARCHAR2,
        p_success     IN VARCHAR2,
        p_message     IN VARCHAR2
    );
END audit_pkg;
/
CREATE OR REPLACE PACKAGE BODY audit_pkg AS
    PROCEDURE log_action(
        p_username    IN VARCHAR2,
        p_action      IN VARCHAR2,
        p_object_type IN VARCHAR2,
        p_object_id   IN VARCHAR2,
        p_success     IN VARCHAR2,
        p_message     IN VARCHAR2
    ) IS
    BEGIN
        INSERT INTO audit_log(username, action, object_type, object_id, attempted_on, success_flag, message)
        VALUES (p_username, p_action, p_object_type, p_object_id, SYSDATE, p_success, p_message);
        -- avoid COMMIT in package for transactional control; but kept in your original â€” keep as is
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END log_action;
END audit_pkg;
/

-- Restriction function (blocks DML on weekdays and holidays)
CREATE OR REPLACE FUNCTION fn_check_restriction RETURN VARCHAR2 IS
    v_day VARCHAR2(10);
    v_today DATE := TRUNC(SYSDATE);
    v_is_holiday NUMBER;
BEGIN
    SELECT TO_CHAR(v_today, 'DY', 'NLS_DATE_LANGUAGE=ENGLISH') INTO v_day FROM DUAL;
    SELECT COUNT(*) INTO v_is_holiday FROM holiday WHERE holiday_date = v_today;

    IF v_is_holiday > 0 THEN
        RETURN 'BLOCK_HOLIDAY';
    ELSIF v_day IN ('MON','TUE','WED','THU','FRI') THEN
        RETURN 'BLOCK_WEEKDAY';
    ELSE
        RETURN 'ALLOW';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RETURN 'ALLOW';
END fn_check_restriction;
/

-- Bulk loader for extraction using FORALL
CREATE OR REPLACE PROCEDURE load_dummy_extractions(p_num IN NUMBER) IS
    TYPE t_site_id IS TABLE OF extraction.site_id%TYPE INDEX BY PLS_INTEGER;
    TYPE t_mineral_id IS TABLE OF extraction.mineral_id%TYPE INDEX BY PLS_INTEGER;
    TYPE t_date_extracted IS TABLE OF extraction.date_extracted%TYPE INDEX BY PLS_INTEGER;
    TYPE t_qty IS TABLE OF extraction.quantity_tons%TYPE INDEX BY PLS_INTEGER;
    TYPE t_shift IS TABLE OF extraction.shift%TYPE INDEX BY PLS_INTEGER;
    TYPE t_operator IS TABLE OF extraction.operator_id%TYPE INDEX BY PLS_INTEGER;

    v_site   t_site_id;
    v_min    t_mineral_id;
    v_date   t_date_extracted;
    v_qtys   t_qty;
    v_shift  t_shift;
    v_ops    t_operator;
BEGIN
    FOR i IN 1..p_num LOOP
        v_site(i) := MOD(i,10)+1;
        v_min(i) := MOD(i,6)+1;
        v_date(i) := TRUNC(SYSDATE) - MOD(i,365);
        v_qtys(i) := ROUND(DBMS_RANDOM.VALUE(0.1,100),3);
        v_shift(i) := CASE WHEN MOD(i,2)=0 THEN 'Day' ELSE 'Night' END;
        v_ops(i) := MOD(i,250)+1;
    END LOOP;

    FORALL idx IN INDICES OF v_site
        INSERT INTO extraction(site_id, mineral_id, date_extracted, quantity_tons, shift, operator_id)
        VALUES (v_site(idx), v_min(idx), v_date(idx), v_qtys(idx), v_shift(idx), v_ops(idx));

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END load_dummy_extractions;
/

-- Procedure using explicit cursor + BULK COLLECT (worker promotions)
CREATE OR REPLACE PROCEDURE promote_technicians(p_years IN NUMBER, p_updated OUT NUMBER) IS
    CURSOR c_workers IS
        SELECT worker_id, name, role, hire_date FROM worker WHERE role = 'Technician' FOR UPDATE;
    TYPE t_worker_tab IS TABLE OF c_workers%ROWTYPE;
    v_workers t_worker_tab;
BEGIN
    OPEN c_workers;
    FETCH c_workers BULK COLLECT INTO v_workers LIMIT 100;
    CLOSE c_workers;

    p_updated := 0;
    FOR i IN 1..v_workers.COUNT LOOP
        IF v_workers(i).hire_date <= ADD_MONTHS(SYSDATE, -12*p_years) THEN
            UPDATE worker SET role = 'Senior Technician' WHERE worker_id = v_workers(i).worker_id;
            p_updated := p_updated + 1;
        END IF;
    END LOOP;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END promote_technicians;
/

-- IN OUT example (adjust hours)
CREATE OR REPLACE PACKAGE io_demo_pkg AS
    PROCEDURE adjust_hours(p_machine_id IN NUMBER, p_hours IN OUT NUMBER);
END io_demo_pkg;
/
CREATE OR REPLACE PACKAGE BODY io_demo_pkg AS
    PROCEDURE adjust_hours(p_machine_id IN NUMBER, p_hours IN OUT NUMBER) IS
    BEGIN
        UPDATE machinery SET hours_run = NVL(hours_run,0) + p_hours WHERE machine_id = p_machine_id;
        SELECT hours_run INTO p_hours FROM machinery WHERE machine_id = p_machine_id;
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            p_hours := NULL;
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END adjust_hours;
END io_demo_pkg;
/

-- Custom exception package
CREATE OR REPLACE PACKAGE custom_ex AS
    e_invalid_quantity EXCEPTION;
    PRAGMA EXCEPTION_INIT(e_invalid_quantity, -20010);
    PROCEDURE validate_quantity(p_qty IN NUMBER);
END custom_ex;
/
CREATE OR REPLACE PACKAGE BODY custom_ex AS
    PROCEDURE validate_quantity(p_qty IN NUMBER) IS
    BEGIN
        IF p_qty < 0 THEN
            RAISE e_invalid_quantity;
        END IF;
    END validate_quantity;
END custom_ex;
/

-- Explicit cursor example (standalone block for testing)
DECLARE
    CURSOR c_extract IS
        SELECT extraction_id, site_id, quantity_tons FROM extraction WHERE ROWNUM <= 200 ORDER BY extraction_id;
    v_id extraction.extraction_id%TYPE;
    v_site extraction.site_id%TYPE;
    v_qty extraction.quantity_tons%TYPE;
BEGIN
    OPEN c_extract;
    LOOP
        FETCH c_extract INTO v_id, v_site, v_qty;
        EXIT WHEN c_extract%NOTFOUND;
        -- processing placeholder
        NULL;
    END LOOP;
    CLOSE c_extract;
END;
/


-- 07_PHASE_TRIGGERS.sql
-- Triggers (Phase VII): audit triggers, revenue calc, safety status, and compound triggers

SET SERVEROUTPUT ON;

-- Audit trigger for extraction (row-level)
CREATE OR REPLACE TRIGGER trg_audit_all
AFTER INSERT OR UPDATE OR DELETE ON extraction
FOR EACH ROW
DECLARE
    v_user VARCHAR2(100) := NVL(USER, 'UNKNOWN');
    v_action VARCHAR2(10);
    v_obj_id  VARCHAR2(100);
BEGIN
    IF INSERTING THEN
        v_action := 'INSERT';
        v_obj_id := NVL(TO_CHAR(:NEW.extraction_id), 'NEW');
    ELSIF UPDATING THEN
        v_action := 'UPDATE';
        v_obj_id := NVL(TO_CHAR(:NEW.extraction_id), 'NEW');
    ELSIF DELETING THEN
        v_action := 'DELETE';
        v_obj_id := NVL(TO_CHAR(:OLD.extraction_id), 'OLD');
    END IF;

    INSERT INTO audit_log(username, action, object_type, object_id, attempted_on, success_flag, message)
    VALUES (v_user, v_action, 'EXTRACTION', v_obj_id, SYSDATE, 'Y', 'Trigger recorded action on extraction');
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END;
/

-- Audit trigger for worker
CREATE OR REPLACE TRIGGER trg_audit_worker
AFTER INSERT OR UPDATE OR DELETE ON worker
FOR EACH ROW
DECLARE
    v_action   VARCHAR2(10);
    v_object_id VARCHAR2(50);
BEGIN
    IF INSERTING THEN
        v_action := 'INSERT';
        v_object_id := TO_CHAR(:NEW.worker_id);
    ELSIF UPDATING THEN
        v_action := 'UPDATE';
        v_object_id := TO_CHAR(:NEW.worker_id);
    ELSIF DELETING THEN
        v_action := 'DELETE';
        v_object_id := TO_CHAR(:OLD.worker_id);
    END IF;

    INSERT INTO audit_log (
        username,
        action,
        object_type,
        object_id,
        attempted_on,
        success_flag,
        message
    ) VALUES (
        NVL(USER, 'UNKNOWN'),
        v_action,
        'WORKER',
        v_object_id,
        SYSDATE,
        'Y',
        'Trigger recorded action on worker'
    );

EXCEPTION
    WHEN OTHERS THEN
        NULL;
END;
/

-- Revenue calculation trigger for extraction
CREATE OR REPLACE TRIGGER trg_extraction_calc_revenue
BEFORE INSERT OR UPDATE ON extraction
FOR EACH ROW
DECLARE
    v_price NUMBER(14,2);
BEGIN
    IF :NEW.quantity_tons IS NULL THEN
        :NEW.quantity_tons := 0;
    END IF;

    BEGIN
        SELECT market_price INTO v_price FROM mineral WHERE mineral_id = :NEW.mineral_id;
        :NEW.revenue_calculated := NVL(:NEW.quantity_tons,0) * NVL(v_price,0);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            :NEW.revenue_calculated := NULL;
    END;
EXCEPTION
    WHEN OTHERS THEN
        :NEW.revenue_calculated := NULL;
END;
/

-- Safety status update trigger
CREATE OR REPLACE TRIGGER trg_safety_status_update
AFTER INSERT ON safety_report
FOR EACH ROW
DECLARE
BEGIN
    IF :NEW.worker_id IS NOT NULL AND :NEW.severity_level IS NOT NULL AND :NEW.severity_level >= 3 THEN
        UPDATE worker SET safety_status = 'UNDER_REVIEW' WHERE worker_id = :NEW.worker_id;
    END IF;
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

-- Compound trigger for extraction that enforces restriction function and audit
CREATE OR REPLACE TRIGGER trg_restrict_dml_compound
FOR INSERT OR UPDATE OR DELETE ON extraction
COMPOUND TRIGGER

    v_status VARCHAR2(30);
    v_user   VARCHAR2(100);

    BEFORE STATEMENT IS
    BEGIN
        v_user := NVL(USER, 'UNKNOWN');
    END BEFORE STATEMENT;

    BEFORE EACH ROW IS
    BEGIN
        v_status := fn_check_restriction();

        IF v_status LIKE 'BLOCK%' THEN
            audit_pkg.log_action(
                v_user,
                'BLOCKED_DML',
                'EXTRACTION',
                NVL(TO_CHAR(:NEW.extraction_id),
                    NVL(TO_CHAR(:OLD.extraction_id),'UNKNOWN')),
                'N',
                'Blocked by restriction: ' || v_status
            );

            RAISE_APPLICATION_ERROR(-20001, 'DML not allowed: ' || v_status);
        END IF;
    END BEFORE EACH ROW;

END trg_restrict_dml_compound;
/

-- Compound trigger for worker (uses same restriction function)
CREATE OR REPLACE TRIGGER trg_restrict_worker_compound
FOR INSERT OR UPDATE OR DELETE ON worker
COMPOUND TRIGGER
    v_status VARCHAR2(30);
    v_user VARCHAR2(100) := NVL(USER,'UNKNOWN');
BEGIN
    NULL;
BEFORE EACH ROW IS
BEGIN
    v_status := fn_check_restriction();
    IF v_status LIKE 'BLOCK%' THEN
        audit_pkg.log_action(v_user, 'BLOCKED_DML', 'WORKER', NVL(TO_CHAR(:NEW.worker_id), NVL(TO_CHAR(:OLD.worker_id),'UNKNOWN')), 'N', 'Blocked by restriction: '||v_status);
        RAISE_APPLICATION_ERROR(-20002, 'DML not allowed: ' || v_status);
    END IF;
END BEFORE EACH ROW;
END trg_restrict_worker_compound;
/

-- Compound trigger for machinery
CREATE OR REPLACE TRIGGER trg_restrict_machinery_compound
FOR INSERT OR UPDATE OR DELETE ON machinery
COMPOUND TRIGGER
    v_status VARCHAR2(30);
    v_user VARCHAR2(100) := NVL(USER,'UNKNOWN');
BEGIN
    NULL;
BEFORE EACH ROW IS
BEGIN
    v_status := fn_check_restriction();
    IF v_status LIKE 'BLOCK%' THEN
        audit_pkg.log_action(v_user, 'BLOCKED_DML', 'MACHINERY', NVL(TO_CHAR(:NEW.machine_id), NVL(TO_CHAR(:OLD.machine_id),'UNKNOWN')), 'N', 'Blocked by restriction: '||v_status);
        RAISE_APPLICATION_ERROR(-20003, 'DML not allowed: ' || v_status);
    END IF;
END BEFORE EACH ROW;
END trg_restrict_machinery_compound;
/






-- 08_PHASE_ANALYTICS.sql
-- Analytics queries using window functions, ranking, LAG/LEAD, moving average.

-- 1. Top sites by total extraction quantity
SELECT
    site_id,
    SUM(quantity_tons) OVER (PARTITION BY site_id) AS total_site_quantity,
    quantity_tons,
    date_extracted
FROM extraction
ORDER BY total_site_quantity DESC NULLS LAST;

-- 2. Rank minerals by revenue using RANK()
SELECT
    mineral_id,
    SUM(revenue_calculated) AS total_rev,
    RANK() OVER (ORDER BY SUM(revenue_calculated) DESC) AS revenue_rank
FROM extraction
GROUP BY mineral_id
ORDER BY total_rev DESC;

-- 3. Compare each extraction with previous extraction at same site USING LAG()
SELECT
    extraction_id,
    site_id,
    date_extracted,
    quantity_tons,
    LAG(quantity_tons, 1) OVER (PARTITION BY site_id ORDER BY date_extracted) AS previous_qty
FROM extraction
ORDER BY site_id, date_extracted;

-- 4. Rolling 7-day average quantity per site
SELECT
    site_id,
    date_extracted,
    quantity_tons,
    AVG(quantity_tons) OVER (
        PARTITION BY site_id ORDER BY date_extracted
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7_days
FROM extraction
ORDER BY site_id, date_extracted;

-- 5. Example analytics: top operators by total quantity
SELECT operator_id, SUM(quantity_tons) total_qty
FROM extraction
GROUP BY operator_id
ORDER BY total_qty DESC NULLS LAST;
